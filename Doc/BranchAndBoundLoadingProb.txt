 装载问题：有一批共n个集装箱要装上2艘载重量分别为c1
和c2的轮船，其中集装箱i的重量为wi，且：
1 2
1
w c c
n
i
i   
 求解目标：确定是否有一个合理的装载方案可将这个集装箱
装上这2艘轮船。如果有，找出一种装载方案。

 装载问题：
如果一个给定装载问题有解，则采用下面的策略可得到
最优装载方案(可证明)：
(1) 首先将第一艘轮船尽可能装满(第一艘船 最优装载)；
(2) 将剩余的集装箱装上第二艘轮船。
将第一艘轮船尽可能装满等价于选取全体集装箱的一个
子集，使该子集中集装箱重量之和最接近。

 采用分支限界法(队列式)的基本思想：用队列Q来存储活结点表。

//队列式实现-定义部分
//队列定义
template <class Type>
class EnQueue(Queue<Type> &Q, Type wt, Type& bestw, int i, int n)
{
    //将活结点加入到活结点队列Q中
    if( i==n)
    {
	if(wt>bestw) bestw=wt;
    }
    else
	Q.Add(wt); //非叶结点
};

//队列式实现-核心函数
//核心函数 
template <class Type> Type MaxLoading(Type w[], Type c, int n)
{ 
    //初始化 
    Queue<Type> Q; //活结点队列 
    Q.Add(-1); //同层结点结尾标志 
    int i=1; //当前扩展结点所处的层 
    Type Ew=0, //扩展结点对应的载重量 
    bestW=0; //当前最优载重量
    while (true) // 检查左儿子结点
    {
	if (Ew + w[i] <= c) //x[i] = 1
	    EnQueue(Q, Ew + w[i], bestw, i, n);
	//右儿子结点总是可行的
	EnQueue(Q, Ew, bestw, i, n); //x[i] = 0
	Q.Delete(Ew); //取下一扩展结点
	if (Ew == -1) //同层结点尾部
	{ 
	    if (Q.IsEmpty()) 
		return bestw;
	    Q.Add(-1); //同层结点尾部标志
	    Q.Delete(Ew); //取下一扩展结点
	    i++; //进入下一层
	}
    }
}

算法的时间复杂性和空间复杂性均为：O(2n)

说明：
1) 首先检测当前扩展结点的左儿子结点是否为可行结点。如果是则将其加入到活结点队列中。
2) 然后将其右儿子结点加入到活结点队列中(右儿子结点一定是可行结点)。2个儿子结点都产生后，当前扩展结点被舍弃。
3) 活结点队列中的队首元素被取出作为当前扩展结点，直到处理完毕。

 定义上界函数进行优化：
1) 引入变量r，r是剩余集装箱的重量：
1
n
j
j i
r w
 
 
2) 定义上界函数bound=Ew+r，其中Ew是当前扩展结点所对应的重量；
3) 假设Z是解空间树第i层上的当前扩展结点，则以Z为根结点的子树中
任一叶节点所相应的载重量均不超过Ew+r。
故：当Ew+r<=bestw时(其中bestw是当前最优载重量)，可将Z的右子树
剪去。

//队列式实现-优化后的核心函数
//核心函数 
template <class Type> Type MaxLoading(Type w[], Type c, int n)
{ 
    //初始化 
    Queue<Type> Q; //活结点队列 
    Q.Add(-1); //同层结点结尾标志 
    int i=1; //当前扩展结点所处的层 
    Type Ew=0, //扩展结点对应的载重量 
    bestW=0; //当前最优载重量 
    r=0; //剩余集装箱的重量 
    for( int j=2; j<=n; j++)
    { 
	r+=w[j]; 
    }
    while (true) // 检查左儿子结点
    {
	Type wt= Ew + w[i] ;
	if ( wt<= c) //可行结点
	{ 
	    if(wt>bestw) bestw=wt; //提前更新bestw
	    //加入活结点队列
	    if(i<n) Q.Add(wt);
	}
	if(Ew+r>bestw && i<n) Q.add(Ew);
	//可能含最优解，不含最优解的右儿子被剪枝
	Q.Delete(Ew); // 取下一扩展结点
	if (Ew == -1) // 同层结点尾部
	{ 
	    if (Q.IsEmpty()) return bestw;
	    Q.Add(-1); // 同层结点尾部标志
	    Q.Delete(Ew); // 取下一扩展结点
	    i++; // 进入下一层
	    r-=w[i];
	}
    }
}

说明： 当算法要将一个活结点加入到活结点队列时，wt的值不会超过bestw，因此不必更新bestw，也不必使用EnQueue来完成插入。

 构造最优解： 为了在算法结束后能方便地构造出与最优值相应的最优解，算法必须存储相应子集树中从活结点到根结点的路径。为此目的，可在每个结点处设置指向其父结点的指针，并设置左、右儿子标志。

class QNode 
{ 
    ……
    //指向父结点的指针 
    QNode *parent; 
    //左儿子标志 
    bool LChild; 
    //结点所相应的载重量 
    Type weight; 
}

//构造当前最优解 
for (int j = n - 1; j > 0; j--) 
{ 
    bestx[j] = bestE->LChild; 
    bestE = bestE->parent; 
}

说明：找到最优值后，可以根据parent回溯到根节点，找到最优解。

 优先队列式分支限界法：
1) 解装载问题的优先队列式分支限界法用最大优先队列存储活结点表。活结点x在优先队列中的优先级定义为从根结点到结点x的路径所相应的载重量再加上剩余集装箱的重量之和。 
2) 优先队列中优先级最大的活结点成为下一个扩展结点。以结点x为根的子树中所有结点相应的路径的载重量不超过它的优先级。子集树中叶结点所相应的载重量与其优先级相同。 
3) 在优先队列式分支限界法中，一旦有一个叶结点成为当前扩展结点，则可以断言该叶结点所相应的解即为最优解。此时可终止算法。