 回溯法(BackTracking)：“通用的解题法”
 回溯法的按深度优先策略： 1）首先定义问题的解空间。 2）从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解： 如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯； 否则，进入该子树，继续按深度优先策略搜索。

引入相关概念：
 扩展结点：一个正在产生儿子的结点称为扩展结点。
 活结点：一个自身已生成但其儿子还没有全部生成的节点称做活结点。
 死结点：一个所有儿子已经产生的结点称做死结点。
 深度优先的问题状态生成法：如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）。

 回溯法的深度优先策略的优化：使用剪枝法来避免无效搜索。这类称为剪枝函数，通常剪枝有两种策略： 1) 用约束函数在扩展结点处减去不满足约束的子树。如： 0-1背包问题中可剪去导致不可行解的子树。 2) 用限界函数剪去得不到最优解的子树。 旅行员背包问题中可剪去费用已经超过现有最好的周游路线费用。

 递归回溯：回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。
void backtrack(int t)
{
    if (t>n) output(x);
    else
        for (int i=f(n,t);i<=g(n,t);i++) 
        {
            x[t]=h(i);
            if (constraint(t)&&bound(t)) backtrack(t+1);
        }
}
1) t表示递归深度，n表示最大递归深度; 
2) output(x)表示输出可行解x; 
3) f(n,t)和g(n,t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号。 
4) contraint(t)和Bound(t)表示在当前扩展结点处的约束函数和上界函数。

 迭代回溯：采用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。

void iterativeBacktrack()
{
    int t=1;
    while (t>0) 
    {
        if (f(n,t)<=g(n,t))
            for (int i=f(n,t);i<=g(n,t);i++) 
            {
		x[t]=h(i);
		if (constraint(t)&&bound(t)) 
		{
		    if (solution(t)) output(x);
		    else t++;
   		}
	    }
        else t--;
    }
}

说明：
1) solution(t)判断在当前扩展结点处是否已经得到问题的解;如已得到，解为：x[1:t]。
2) f(n,t)和g(n,t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号。
3) contraint(t)和Bound(t)表示在当前扩展结点处的约束函数和上界函数。