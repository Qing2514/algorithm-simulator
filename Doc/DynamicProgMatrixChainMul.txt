 矩阵A和B的可乘条件：A的列数等于B的行数。
 令A是p*q的矩阵，B是q*r的矩阵，则乘积C=AB是一个p*r的矩阵，其计算需q*r*p次乘法。
 矩阵乘法的结合律(Associative Law)：令矩阵A1和A2可乘，矩阵A2和A3可乘，则有：
A1 A2 A3= (A1 A2) A3=A1 (A2 A3)

 矩阵连乘(Matrix-Chain Multiplication)：给定n个矩阵{A1, A2, A3, … , An}，其中Ai与Ai+1是可乘的，计算这n个矩阵的连乘积A1 A2 A3 … An。
 从矩阵乘法的结合律可看出， n个矩阵的连乘积可有多种计算次序。
 完全加括号的n个矩阵连乘积的定义(用于确定矩阵连乘的计算次序)：
1）单个矩阵是完全加括号的；
2）矩阵连乘积 A是完全加括号的，则 A可表示为2个完全加括号的矩阵连乘积 B和C的乘积并加括号，即 A=(BC) 。

 矩阵连乘计算示例： 设A1, A2, A3分别为10*100， 100*5和5*50的矩阵，则有： 1）A1 A2 A3= (A1 A2) A3需10*100*5+10*5*50=7500次乘法。 2）A1 A2 A3=A1 (A2 A3)需100*5*50+10*100*50=75000次乘法。
结论：矩阵连乘积的计算次序对其计算量的影响非常大！

 动态规划法(Dynamic Programming)：将矩阵连乘积A1A2…An 简记为A[1:n] ，其中 1≤n。 1) 分析最优解的结构：考察计算A[1:n]的最优计算次序。将矩阵序列A[1:n]分解为A[1:k]和A[k+1:n]。 2) 建立递归关系：找出矩阵序列和子矩阵序列的最小乘法次数之间的关系。 3) 计算最优值：比较并找出矩阵连乘的最小乘法次数。 4) 构造最优解：使用回溯法(Traceback)找出最优加括号次序。

 动态规划法(一)：分解最优解的结构 1) 考察计算A[1:n]的最优计算次序。设该最优计算次序在矩阵 Ak和Ak+1之间将矩阵链断开，1≤k<n，则其相应的完全加括号方式为： ( (A1A2…Ak)(Ak+1Ak+2…An) )。 2) 显然，子矩阵序列 (A1A2…Ak)和 (Ak+1Ak+2…An)的计算次序也须是最优的(可用反证法证明)。 3) 矩阵连乘计算次序问题的最优解实际上包含着其子问题的最优解，这种性质称为最优子结构性质(Optimal Substructure)。

 动态规划法(二)：建立递归关系 1) 令计算A[i:j] (其中1≤ i≤j≤n)所需的最少乘法次数为m[i,j]，则A[1:n]计算次序问题的最优值为m[1, n]。 2) 当i=j时，A[i:j]=A[i:i]=Ai，因此，m[i,i]=0，i=1,2,…,n 3) 当i<j时，设矩阵序列A[i:j]的最优次序在Ak和Ak+1处断开，则 m[i,j]= m[i,k]+ m[k+1, j]+ pj pi-1 pk (其中Ai的维数为pi-1*pi )。

 动态规划法(三)：计算最优值
1) 令计算A[i:j] (其中1≤ i≤j≤n)所需最少数乘法次数为m[i,j] 。
2) 根据m[i,j]的递归式可编写自顶向下的递归算法来计算m[1,n]，这种方法将会耗费指数级的计算时间。
3) 实际上，有序对(i, j)的选择共有 种，相应的子问题也最多有 个，因此可采用自底向上的递归或非递归方法(每个子问题只计算一次)来消去自顶向下的递归算法中对于相同子问题的重复计算。

//动态规划法(三)：计算最优值(实现)
void MatrixChain(int *p，int n，int **m，int **s)
{
    for (int i = 1; i <= n; i++) 
	m[i][i] = 0; //矩阵链长度为1
    for (int r = 2; r <= n; r++)  //矩阵链长度为r，逐步增加
    { 
	for (int i = 1; i <= n - r+1; i++) 
	{
	    int j=i+r-1;
	    m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j];
	    s[i][j] = i;
	    for (int k = i+1; k < j; k++) //计算长度为r的最优值
	    {
		int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
		if (t < m[i][j]) 
		{ 
		    m[i][j] = t; 
		     s[i][j] = k;
		}
	    }
	}
    }
}


说明： 
1) s[i][j]为最优次序的断开位置； 
2) 算法时间复杂度取决于三重循环，为：O(n^3)； 
3) 算法空间复杂度为：O(n^2)


//构造最优解，根据s[i,j]可回溯追踪出各个断开处(即加括号处)，代码如下：
void Traceback( int i, int j, int **s)
{ 
    if(i==j) return; 
    Traceback(i, s[i][j], s); 
    Traceback(s[i][j]+1, j, s); 
    cout<<“Multiply A”<<i<<“,”<<s[i][j]; 
    cout<<“ and A”<<(s[i][j]+1)<<“,”<<j<<endl; 
}